question is searching in sorting and rotated array (Single Binary Search)

ip =[5,6,7,8,9,10,1,2,3]  key = 3 op = 8 

//basically in searching and doing binary search we have 3 params low, mid and high 

conditions :- 
arr mid >= arr low   (left sorted)
arr mid <= arr high (right sorted)
arr low  > key (searching is not in left , move to right)
arr high < key (searching is not in right , move to left)
key > arr mid & k < high (update low = mid + 1)
key >= mid , key <= high   (right sorted)
arr mid = key   return index 


function search(arr, key){
    let low = 0 , h = arr.length -1;

    while(l <= h){
        let mid = l + Math.floor(h-l/2);

        //if key found, return index 

        if(arr[mid] === key)
        return mid;

        //if left half is sorted
        if (arr[mid] >= arr[low]){
            //if key lies within this sorted half, move h pointer to mid m-1
            if ( key >= arr[low] && key < arr[mid])
                    h = mid - 1;

//otherwise move 
else {
    low = mid + 1 ;
}else{
    if ( key >= arr[mid] && key <= arr[h])
                l = mid + 1;
}else{
    h = mid - 1;                   // otherwise move to h = mid - 1
}
        }
        return -1;   //key not found 
    }
}


question : peak element in array 


ip = [1,2,4,5,7,8,3]
o/p = 5  ,, so element 8 is at its peak 

if a[0] > a[i] (we will have o/p in right) nd vice versa


function pealElement(arr){
    let n = arr.length;

    if ( n===1){
        return 0;

        //if first element is at peak 

        if (arr[0]> arr[1])
        return 0;

        //if last element is at its peak 

        if (arr[n-1] > arr[n-2])
        return n-1;

        //search space for binary search 

        let l =1 , h = n-2;
         while (l <= h){
            let mid = l + Math.floor((h-l/2));

        //if element at mid is a peak , return  mid 

            if(arr[mid] > arr[mid -1 ] && arr[mid] > arr[mid+1])
            return mid ;

        //if next neighbour  > peak will exist in right subarray 

                if (arr[mid] < arr[mid+1])
                l = mid + 1;
            else  h = mid -1 ;                         //left subarray

         }
         return 0;
    }
}

Question is Counting element in 2 arrays :-

//2 unsorted array may contain duplicates 

arr1 = [1,2,3,4,7,9] arr2 = [0,1,2,1,1,4]   o/p = [4,5,5,6,6,6]

function countelement(arr1,arr2,m,n){
    arr1.sort();
    arr2.sort();
//pointer for arr2

let j = 0;
for(let i =0;i<m;i++){
    while(j < n && arr2[j] <= arr[i])
    j++;
    console.log(j + " ");
}
}

let m = arr1.length;
let n = arr2.length;

countelement(arr1,arr2,m ,n);

question is allocate minimum pages (Binary Search)

arr[i] = no of pages in a book and k = total no. of books 
//each student should atleast get one book otherwise return -1 ;

input = [12,34,67,90] k =2 o/p = 113

function check(arr, k , pageLimit){
    let cnt = 1;
    let pageSum = 0;
    for (let i =0;i<arr.length;i++){
          //if adding current book > page limit  assign book to next student
          if(pageSum + arr[i] > pageLimit){
            cnt++;                      //assigning book to next student
            pageSum = arr[i];
          }else {
            pageSum += arr[i];
          }
    }

//if books can be assigned < k students assigned exactly to students as well

return cnt <= k ;
}

function findPages(arr,k){
    if(k > arr.length)
    return -1;

    //search space for binary search

    let l = Math.ma(...arr);
    let h = arr.reduce((a,b) => a+b,0);
    let res = -1;

    while (l <= h){
        let mid = l + Math.floor((h-l)/2);

        if(check(arr,k,mid)){
            res = mid;
            h = mid -1;
        }else {
                l = mid + 1;
        }
    }
    return res;
}


question is median of two sorted arrays of different sizes :--(Binary Search)

tip:- always check if first array is smaller than second 
1. first partition (mid1 = o to mid -1)
2. second partition (mid2 = ((n+m+1)/2 - mid1))

//now we want to find one point in both array so that point should be smaller than 1 & > than2 .

function medianfotwo(a,b){
    let n = a.length;
    let m = b.length;

//if a[] has more elements then call funtion with reversed parameter 

    if (n > m)
    return medianof2(b,a);

    let l = 0;h = n ;
    while (l <= h){
        let mid1 = Math.floor((h-l)/2) - mid1;
    let mid2 = Math.floor((n+m+1)/2) - mid1;

//now find element in left and right position 


let l1 = (mid1 === 0) ? Infinity : b[mid1-1];
let r1 = (mid1 === m) ? Infinity : a [mid1];

 let l2 = (mid2 === 0) ? Infinity : b[mid2-1];
 let r2 = (mid2 === m) ? Infinity : a [mid2];

// if valid partition 
   if(l1 <= r2 && l2 <= r1){
    if ((n+m) % 2 === 0)
    return (Math.max(l1,l2) + Math.min(r1,r2)) /2;
//check if we need to take more elements from a[]


else return Math.max(l1,l2);
}
if(l1>r2)
h = mid -1 ;
else 
l = mid1 + 1;

}
return o ;
}



